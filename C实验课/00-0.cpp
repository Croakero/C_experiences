/*
思路：
这个题有点意思啊有点意思
先把矩阵读到m行n列二维数组里，a[m][n]。
我的建议是做一个指向其列数这一一维数组的指针ptr 
这样我就可以用这个指针横向和纵向移动了。 
它现在指向第一行第一列，取它的ptr[0]，
然后ptr++，取0，ptr--，取1，
这其中暗藏了一些我尚未发现的数学规律
我想想啊，如果行数，即ptr+1没怼到外面去，但是这怎么判断呢？
每次对ptr++的时候，一个计数器p跟着递增，初始值为0，
如果计数器是m-1，那么此时不再ptr++，变成q++,ptr[q+1]
然后ptr--，q++直到q怼到n-1上面去
********** 试错之后 
观察到Z扫描可以可以分为三个过程，一个是上三角扫描过程，
一个是连续续扫描相同大小的斜线i次，和有规律下三角扫描。
 把不同的做法定义为函数，然后操控指针移动，不需要指针有那么高的智能。
 
*/
#include<stdio.h>
int main(void){
	int m,n;
	scanf("%d%d",&m,&n);
	int a[n][m];//m行n列的一个数组 
	for(int i=0;i<n;i++){//循环读取数组内容
		for(int j=0;j<m;j++){
			scanf("%d",&a[i][j]);
		}
	}
	int (*ptr)[m]=&a[0];
	int i=0,j=0;//两个计数器,i管行j管列 
	while(i!=n-1&&j!=m-1){
		printf("%d",(*ptr)[j]);
		if(j==0){//如果在第一列 
			if(i!=n-1){//如果没有被逼到右上角,注意还要处理右上角，放在竖着的一起处理 
				ptr++;
				i++;
				printf("%d",(*ptr)[j])
				while(i!=0){//现在要管斜向的
					ptr--;
					j++;
					
				}
			}
		}
	}
} 
